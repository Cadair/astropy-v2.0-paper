\documentclass[modern]{aastex61}
\usepackage{xspace}
\newcommand{\escapecmd}[1]{\texttt{\detokenize{#1}}}

\submitjournal{ApJ}

\shorttitle{Astropy Project II}
\shortauthors{Astropy Project et al.}

% Packages / projects / programming - for consistency!
\newcommand{\package}[1]{\texttt{#1}\xspace}
\newcommand{\github}{\package{GitHub}\xspace}
\newcommand{\python}{\package{Python}\xspace}
\newcommand{\astropy}{Astropy\xspace}
\newcommand{\astropypkg}{\package{astropy}\xspace}

% For consistency:
\newcommand{\sectionname}{Section\xspace}
\renewcommand{\figurename}{Figure\xspace}
\newcommand{\equationname}{Equation\xspace}
\renewcommand{\tablename}{Table\xspace}

% For commenting - can be deleted before submission
\usepackage[colorinlistoftodos]{todonotes}
\newcommand{\inlinecomment}[2]{\todo[inline]{#1: #2}\xspace}
\newcommand{\comment}[2]{\todo{#1: #2}\xspace}

\begin{document}

\draft{\today}

\title{The Astropy Project}

\correspondingauthor{Astropy Coordination Committee}
\email{coordinators@astropy.org}

\author{Astropy Collaboration}

\begin{abstract}
% I (Adrian) took a first stab at the abstract, but it needs some work. Feel
% free to modify!
The \astropy project supports and fosters the development of open-source
\python packages that provide commonly-needed functionality to the astronomical
community.
A key element of the project is the \astropy core package, which serves as the
foundation for more specialized projects and packages.
In this article, we provide an overview of the organization of the \astropy
project and summarize key features in the core package as of the recent major
release, version 2.0.
We then describe the project infrastructure designed to facilitate and support
development for a broader ecosystem of inter-operable packages.
We conclude with a future outlook of planned new features and directions for the
broader \astropy project.
\end{abstract}

%% Keywords should appear after the \end{abstract} command.
%% See the online documentation for the full list of available subject
%% keywords and the rules for their use.
\keywords{}

\section*{\textit{Notes and guidelines (to be removed)}}

\begin{itemize}
   \item The goal is to produce a brief and informative paper that covers major
        \astropy principles not mentioned in the first paper, the core v2.0
        package, and infrastructure in \astropy project to support development
        in \python.
    \item We don't plan on including code in this paper, but if you think you
        will need to include code in your section, please add it to a separate
        Python module (.py file) and include it in this repository.
    \item Use \escapecmd{\sectionname} not ``Section,'' \escapecmd{\figurename}
        not ``Figure''
    \item Use \escapecmd{\astropypkg} for the astropy package,
        \escapecmd{\astropy} for the astropy project, \escapecmd{\python} not
        ``Python''
    \item If your subpackage was included in Paper I, then please just include a
        note on what the package does, a reference to paper I, and any new major
        updates to your package
    \item If your subpackage was not included, then please describe the
        sub-package on level with what was in the first paper, and highlight any
        major features in it. Typical length should be equivalent to one page
        (single-column).
    \item Please make sure you are logged into Overleaf or pushing a commit with
        your information to be able to track the contributors to the paper.

\end{itemize}

\section{Introduction} \label{sec:intro}
% first draft by Moritz (hamogu)
All astronomical research makes use of software in some way and
astronomy as a field has long supported the development of specialized
software tools for different astronomical tasks. Some of those
software packages are (or at least were) supported by large
institutions, e.g.~IRAF \citep[developed at NOAO,][]{IRAF}, MIDAS
\citep[developed at ESO,][]{MIDAS}, or ds9 \citep[developed at
% * <bsipocz@gmail.com> 2017-09-28T21:05:00.569Z:
%
% > or ds9
% probably starlink is a better example as being a large package of software similarly to IRAF and MIDAS rather than a single tool.
%
% ^.
% hamogu: Feel free ot swap in Starlink, if you think that's more appropriate. I picked ds9 becase (a) it's wider known (e.g. in the X-ray sounity) and (b) because it is an example of a widely used tool with institutional support that is NOT a large package. TOPCAT would have been another example if we want to expand that list.
  SAO,][]{ds9}. These packages tend to address a wide range of users
and they typically provide some level of documentation and user
support. Other packages are developed foremost by individual research
groups and used mostly in work by members of this group. Those
packages can address more specialized needs, but are not necessarily
available to the community and even if they are, documentation can in
some cases be insufficient for new users and the quality of the
software, i.e. the robustness and the level of testing that has been
performed to ensure correctness, is not always clear. On the other
hand, there are also many widely used, well documented, high quality
software packages which are developed by individuals or small groups.

The implementation of astronomical software, be it for a package meant
for wide distribution or scripts and programs for a specific research
project, can be eased by the use of a library that provides core
functionality that is common to many astronomical tasks. Reading and
writing FITS files is one example where it is time
consuming to implement the FITS standard correctly and
programming is much faster when using an existing library perform this
task. Another example of such a common task is dealing with different
astronomical coordinate systems. The \astropy project aims to provide a
library of core astronomical functionality in the \python programming
language.

\python\footnote{\url{https://www.python.org/}} is an increasingly popular
general-purpose scripting language that is available under a permissive open
source software licence free of charge for all major operating systems. Stable
and well-developed packages provide support for array arithmetic
\citep[\package{numpy},][]{numpy}, a wide variety of functions for scientific
computing \citep[\package{scipy},][]{numpy}, and publication-quality plotting
\citep[\package{matplotlib},][]{matplotlib}. Tens of thousands of other packages
are available which can help with tasks that are not astronomy specific but
might be performed in the course of astronomical research, e.g., presenting
results on websites or interfacing with databases.

At the same time, an ecosystem of tools, programs, and webservices
has become available that makes it easier to collaborate on code development,
continuously test the code, build and provide documentation, and
supply downloadable packages. The \astropy project aims to develop and
provide high quality code and documentation according to the best
practices in software development. The project makes use of these
tools to do so without central institutional oversight.

The first public release of the \astropy package is described in
\cite{astropy}. Since then, the \astropy package has been
used in hundreds of projects, and the scope of the package as grown
considerably. At the same time, the community of astronomers
contributing to the project has grown tremendously and an ecosystem
of packages supporting or affiliated with the \astropy core has
developed. In this paper, we describe the current status of the
\astropy community, the \astropy core package, and the \astropy\
ecosystem.

We start by describing the way the \astropy project works and is
organized in \sectionname~\ref{sec:concepts}.  The project develops a core
package called \astropypkg (\sectionname~\ref{sec:core}) and several
separate packages that help setting up the infrastructure for testing,
documentation etc.~(\sectionname~\ref{sec:infrastructure}). In
\sectionname~\ref{sec:learning} we give an overview of the wealth of
resources created to teach new users the use of the \astropy packages
and how to contribute to the community. We end with a short vision for
the future of \astropy in \sectionname~\ref{sec:future}.



\section{Major concepts}
\label{sec:concepts}
% Anyone want to take this??

\subsection{Coordination of Astropy}
% Kelle

\subsection{APEs - Astropy Proposals for Enhancement}
%draft by hamogu
Central to the success of \astropy is an open environment where
anybody can contribute to the code by opening a so-called ``pull
request'' with a new code contribution on an publically available
website\footnote{\url{https://github.com/astropy/astropy}}; this
request is then reviewed by a maintainer responsible for the specific
sub-package and possibly merged into the main code base. Most bug
fixes and small features are contributed in this way. However, this
model leads to ``organic'' growth where different features are
implemented by different people with different programming styles and
interfaces. Thus, \astropy has a mechanism to more formally propose
changes to the code management (e.g.~the release cycle) or to plan
out major new features. This mechanism is called ``Astropy Proposal
for Enhancement'' (APE). In an APE one or more authors lay out a
vision for a new feature, including a rationale why this feature is
needed, how it should be implemented, and what the interface will
be. These APEs are discussed and refined before much work is invested
into a detailed implementation. APEs are again edited and discussed on
a platform \footnote{\url{https://github.com/astropy/astropy-APEs}}
open to the public. In previous APEs a community concensus emerged and
APEs are accepted and become the basis for future work at this
point. In cases where consensus cannot be reached, the
\astropy coordination committee can decide to close the discussion and
make an executive decision based on the community input on the APE in
question. APEs are modeled after the ``Python Enhancement Proposals''
(PEP) and guide the development of the \python programming language.


\subsection{Astropy development model, astropy ecosystem}
% Erik
This subsection should include some basic statistics about the contributors, commits, line of code etc. up to the 2.0 release when we know it.

\subsection{Concept of affiliated packages}
% it may be described in previous subsection, if not the Brigitta can try to
% write it up
%
\par A major part of the \astropy project is the concept of “Affiliated
Packages”. An affiliated package is an astronomy-related \python package that
is not part of the \astropypkg core package, but has requested to be
included as part of the astropy project’s community. These packages support
the goals and vision of \astropy of improving code reuse,
interoperability, and embracing good coding practices such as testing and
thorough documentation. \astropypkg currently supports both versions of
\python~2.7 and \python~3.4+, affiliated packages are strongly encouraged to
support at least \python~3.x.
%
\par Affiliated packages contain functionality that is more specialized, or
have license incompatibility, or have enough external dependencies (e.g. GUI
libraries) that limit their integration possibility into the core and thus
they are more suitable to be separate packages. In general we hope that
becoming an affiliated package is seen as a good way for new and existing
packages to gain exposure.
%
% TODO: write about the process of becoming affiliated, and project packages
%
\subsection{Mixin}

\subsection{Accuracy testing across many different implementation}

\subsection{Use of Quantities across package}
% Marten and Tom R.

{\bf Very rough first text!}

Historically, it has been unusual to keep units as part of numbers, especially as speed was often deemed essential and quantities used to be slower than regular arrays. Hence, programs and functions expected to be fed parameters in particular units, as (hopefully) stated in their documentation.  In \astropypkg~0.4, therefore, unit and quantity support was still somewhat spotty, but this has changed greatly.  One of the riskiest classes was angles, where both degrees and radians were ``obvious'' default units to some. As a consequence, quantities are most fully integrated in the coordinates module (\sectionname~\ref{sec:coordinates}). In \astropypkg~2.0, one can also opt in to use quantities fully in tables, by using the {\tt QTable} class (see \sectionname~\ref{sec:table}). As a result, units in FITS tables are also well-supported. For most other modules, quantities are at least accepted, and often assumed by default.

In the process, some standard wrappers have been defined that make defining functions that require quantities as input simpler. As an extension of this, we plan to define wrappers for functions that work on numbers that will automatically convert quantities to any required units.

\subsection{Release cycle and Long Term Support}
% This could also include information about the development cycle
% Brigitta can writes this up if there's no other taker
\inlinecomment{BMS: TODO}{reference APE2 for versioning and APE10 for dropping python2 support}
\inlinecomment{BMS}{shall we maybe refer to the release calendar, too?}
\inlinecomment{BMS}{should we mention that v3.0 is the exception to the
  version numbering scheme we use by not being 2.1?}
%
\par The general scheme for the releases and version numbering that the core
package has adopted if the following. \astropypkg has new feature releases every
6 months, and between feature releases additional bugfix releases that
contain only bugfixes but no new features. The timing of
%
\par Long-term support (LTS) releases continue to receive bugfixes for 2
years with no changes to the API. They are ideal for pipelines and other
applications where API stability is essential. The latest LTS release is
also the last one that supports \python 2, and will receive bug fixes until the
end of 2019.
%
\par The version numbering of \astropypkg reflects on the release scheme
described above. The core package uses the form x.y.z, where x is advances
on LTS, y is advanced for a non-LTS feature release, and z is advanced on
bugfix releases.

\subsection{Support of Astropy}

% This section should be a straight forward/factual description of the current
% funding and support provided to astropy with the purpose of explaining the
% current structure to the community

%\subsection{Difficulty of reversing design choices}
%Deciding if a feature should be included
%difficulty to decide where general use ends and "handy feature for some" starts, i.e. how to reject PRs or deal with maintenance burden

\section{Astropy Core Package v2.0}
\label{sec:core}

The \astropy project aims to provide \python-based packages for all tasks that
are commonly needed in a large subset of the astronomical community.
At the foundation is the \astropypkg core package, which provides general
functionality (e.g., coordinate transformations) or base classes for other
packages to utilize for a common interface (e.g., \texttt{NDData}).
In this section, we highlight new features introduced or substantially improved
since version v0.2 (previously described in \citealt{astropy}).

% \subsection{Analytic Functions}
% moved to models and depreciated --
% just here for completeness at the moment

\subsection{Units and quantities}
\label{sec:units}
% Marten, Adrian

The \package{astropy.units} subpackage provides ...

\subsubsection{Key new features}

\begin{description}
    \item[Speed improvements] ...
    \item[Logarithmic units and magnitudes] ...
    \item[Interaction with \package{numpy} arrays] ...
\end{description}

\subsection{Constants}
% David S.
versioning


\subsection{Coordinates}
\label{sec:coordinates}
% Adrian, Erik

\subsubsection{Overview}
The \package{astropy.coordinates} subpackage is designed to support representing
and transforming celestial coordinates and, new in version 2.0, velocities.
The framework heavily relies on the \package{astropy.units} subpackage, and most
inputs to objects in this subpackage are expected to be \texttt{Quantity}
objects.
Some of the machinery also relies on the Essential Routines of Fundamental
Astronomy (ERFA) \texttt{C} library for some of the critical underlying
transformation machinery.
\inlinecomment{EJT}{Need to create a Zenodo DOI for ERFA and then cite it here.}
% * <tjenness@lsst.org> 2017-10-16T15:53:18.375Z:
%
% I think it should mention that ERFA is related to SOFA (and cite SOFA).
%
% ^.
A key concept behind the design of this subpackage is that coordinate
\textit{representations} and \textit{reference systems / frames} are independent
of one another.
For example, a set of coordinates in the International Celestial Reference
System (ICRS) reference frame could be represented as spherical (right
ascension, declination, and distance from solar system barycenter) or Cartesian
coordinates ($x$, $y$, $z$ with the origin at ).
They can therefore change representations independent of being transformed to
other reference frames (e.g., the Galactic coordinate frame).

The classes that handle coordinate representations (the \texttt{Representation}
classes) act like three-dimensional vectors and thus support vector arithmetic.
The classes that represent reference systems and frames (the \texttt{Frame}
classes) internally use \texttt{Representation} objects to store the coordinate
data---that is, the \texttt{Frame} classes accept coordinate data, either as a
specified \texttt{Representation} object, or using short-hand keyword arguments
to specify the components of the coordinates.
These preferred representation and short-hand component names differ between
various astronomical reference systems.
For example, in the ICRS frame, longitude and latitude are right ascension
(\texttt{ra}) and declination (\texttt{dec}), whereas in the Galactic frame, the
spherical angles are Galactic longitude (\texttt{l}) and latitude (\texttt{b}).
Each of the \texttt{Frame} classes define their own component names and
preferred \texttt{Representation} class.
The frame-specific component names map to corresponding components on the
underlying \texttt{Representation} object that internally stores the coordinate
data.
For most frames the preferred representation is spherical, although this is
determined primarily by the common use in the astronomical community.

Many of the \texttt{Frame} classes also have attributes specific to the
corresponding reference system that allow the user to specify the frame.
For example, the Fifth Fundamental Catalogue (FK5) reference system requires
specifying an equinox to determine the reference frame.
If required, these additional frame attributes must be specified along with the
coordinate data when a \texttt{Frame} object is created.
\figurename~\ref{fig:frame-transform-graph} shows the network of possible
reference frame transformations as currently implemented in
\texttt{astropy.coordinates}.
Custom, user-implemented \texttt{Frame} classes that define transformations to
any reference frame in this graph can then be transformed to any of the other
connected frames.

\begin{figure}
\includegraphics[width=\textwidth]{coordinates_graph.pdf}
\caption{
    The full graph of possible reference frame transformations implemented in
    \texttt{astropy.coordinates}.
    \label{fig:frame-transform-graph}
}
\end{figure}

The typical user doesn't usually have to interact with the \texttt{Frame} or
\texttt{Representation} classes directly.
Instead, \texttt{astropy.coordinates} provides a high-level interface to
representing astronomical coordinates through the \texttt{SkyCoord} class.
The \texttt{SkyCoord} class was designed to provide a single class that
accepts a wide range of possible inputs.
It supports coordinate data in any coordinate frame in any representation by
internally using the \texttt{Frame} and \texttt{Representation} classes.

\subsubsection{Key new features}

\begin{description}
    \item[Local Earth coordinate frames] In addition to representing celestial
    coordinates, \astropypkg now supports specifying positions on the Earth in
    a number of different geocentric systems with the \texttt{EarthLocation}
    class.
    With this, \astropypkg now supports Earth-location-specific coordinate
    systems such as the altitude-azimuth (\texttt{AltAz}) or horizontal system.
    Transformations between \texttt{AltAz} and any Barycentric coordinate frame
    also requires specifying a time using the \texttt{Time} class from
    \texttt{astropy.time}.
    With this new functionality, many of the common tasks associated with
    observation planning can now be completed with \astropypkg or the
    \astropy-affiliated package \package{astroplan}. \inlinecomment{APW}{TODO: cite zenodo entry for astroplan?}.

    \item[Proper motion and velocity transformations]
    In addition to positional coordinate data, the \texttt{Frame} classes now
    also support velocity data.
    As the default representation for most frames is spherical, most of the
    \texttt{Frame} classes expect proper motion and radial velocity components
    to specify the velocity information.
    The names of the proper motion components all start with \texttt{pm} and
    adopt the same longitude and latitude names as the positional components.
    Transforming coordinates with velocity data is also supported, but in some
    cases the transformed velocity components have limited accuracy because the
    transformations are done numerically.
    The visualization of the coordinate frame transform graph highlights which
    velocity transformations can be done exactly and which transformations are
    done using a finite-difference scheme.
    The low-level interface for specifying and transforming velocity data (see
    the next point) is currently experimental.
    As such, in v2.0, only the \texttt{Frame} classes (and not the
    \texttt{SkyCoord} class) support handling velocities.

    \item[Derivatives of coordinate representations]
    As mentioned above, the \texttt{Representation} classes act like
    three-dimensional vectors.
    \texttt{astropy.coordinates} now also supports handling first derivatives of
    vectors / representations through the new \texttt{Differential} classes.
    The \texttt{Differential} classes are currently used internally within the
    \texttt{Frame} classes to store the velocity data.

    \item[Solar System Ephemerides]
    Also new is support for computing ephemerides of major solar system bodies
    and outputting the resulting positions as coordinate objects.
    These ephemerides can be computed either using analytic approximations from
    ERFA, or from downloaded JPL ephemerides (the latter requires the \package{j
    plephem}\footnote{\url{https://github.com/brandon-rhodes/python-jplephem}}
    optional dependency and an internet connection).
    The \texttt{get\_body} and \texttt{get\_body\_barycentric} functions provide
    the gateway to this functionality, yielding \texttt{SkyCoord} objects given
    a specific body and choice of ephemeris source.

\end{description}

\subsubsection{Accuracy and comparison of coordinate system definitions}
% Erik?

\subsection{Time}
\label{sec:time}

Q: does it make sense to refer forward to FITS support, even though it is 3.0?

\inlinecomment{EJT}{ERFA is likely to be referenced somewhere here. should cite the DOI as mentioned in the above ERFA refernce once it exists}

\subsection{Data arrays}

\subsubsection{NDDdata}
% Matt C., Michael, or Steve C.
% Larry (nddata.utils)
%NOTE (Larry), The package is nddata, which includes the NDData object.  %Don't forget the nddata.utils functionality (e.g. Cutout2D, block\_reduce, %etc.).

\subsubsection{Tables}
\label{sec:table}
% Tom A.
QTable is new, mixin columns for time and coordinates. Table operations were added in v0.3

\subsection{io}
% Simon

The \package{astropy.io} subpackage provides support for reading and writing
various formats: a wide range of ASCII data table formats, FITS, VOTable, etc.
It also provides a unified interface for reading and writing data with these
different formats, using the \package{astropy.table} subpackage.
For many common cases this simplifies the process of file I/O and reduce the
need to master the separate details of all the I/O packages within Astropy.
% This functionality is still in active development and the number of supported
% formats will be increasing.

\inlinecomment{SCO}{Pyfits deprecation in favor of io.fits ?}
\inlinecomment{SCO}{Table and FITS tables}

\subsubsection{Unified file read/write interface}

Check when it was added (0.3?). Overview of the supported formats (ASCII,
FITS, votable, HTML, JSViewer/Datatables).

\subsubsection{Key new features}

\inlinecomment{SCO}{One subsection per format (if enough new features) ?}

\begin{description}

    \item[ASCII: fast reader/writer (v1.0)]

		The \package{astropy.io.ascii} module now includes a significantly faster
		Cython/C engine for reading and writing ASCII files. This is available
		for the following formats: basic, commented\_header, csv, no\_header,
		rdb, and tab.  On average the new engine is about 4 to 5 times faster
		than the corresponding pure-Python implementation, and is often
		comparable to the speed of the pandas ASCII file interface. The fast
		reader has parallel processing option that allows harnessing multiple
		cores for input parsing to achieve even greater speed gains.

		By default, read() and write() will attempt to use the fast C engine when
		dealing with compatible formats. Certain features of the full read / write
		interface are not available in the fast version, in which case the
		pure-Python version will automatically be used.

    \item[ASCII: HTML tables (v0.4)]

		The \package{astropy.io.ascii} sub-package now provides the capability
		to read a table within an HTML file or web URL into an astropy
		\texttt{Table} object. This requires the \package{BeautifulSoup4}
		package to be installed.  Conversely a \texttt{Table} object can now
		be written out as an HTML table.

	\item [Enhanced CSV format (v1.0)]

		One of the problems when storing a table in an ASCII format is
		preserving table meta-data such as comments, keywords and column data
		types, units, and descriptions. Using the newly defined \emph{Enhanced
		Character Separated Values} (ECSV) format it is now possible to write
		a table to an ASCII-format file and read it back with no loss of
		information. The ECSV format has been designed to be both
		human-readable and compatible with most simple CSV readers.

	\item [FITS: command-line scripts (\texttt{fitsheader}, \texttt{fitsinfo}, v0.4)]

		The \package{astropy.io.fits} sub-package now provides a command line
		script for inspecting the header(s) of a FITS file.  Running
		\texttt{fitsheader file.fits} in a terminal prints the header
		information to the screen in a human-readable format. Run
		\texttt{fitsheader --help} to see the full usage documentation.

	\item [FITS: lazy loading (v1.3)]

		The \package{astropy.io.fits} sub-package now supports \emph{lazy
		loading}, where all HDUs are not loaded until they are requested (or
		the file is closed). This should provide substantial speedups for
		situations using the convenience functions (e.g., \texttt{getheader()}
		or \texttt{getdata()}) to get HDU’s that are near the front of a file
		with many HDU’s.

	\item [Misc: YAML serialization (v1.3)]

		The new \package{astropy.io.misc.yaml} module allows converting
		astropy objects into a standard YAML format.
        This can be used beyond \texttt{astropy.io.misc.yaml}: for example, to
        serialize the metadata of tables before saving to other formats like
        HDF5.

\end{description}

\subsection{Modeling}
\label{sec:modeling}
% Nadia
% Lim blackbody
% Tom R. -- unit support
The whole modeling submodule was missing from the previous paper, so everything really, including compound models, unit support etc.

\subsection{Convolution}
% Adam G.

\astropypkg implements `normalized convolution' \citep[e.g.,][]{Knutsson1993}, which is an image reconstruction technique in which missing data are ignored during the convolution and replaced with values interpolated using the kernel.   In version $<=1.3$, the direct convolution and fft convolution approaches were not consistent, with fft convolution implementing normalized convolution and direct convolution implementing a different approach.  As of v2.0, the two methods are consistent and include a suite of consistency checks.


\begin{figure}
\includegraphics[width=\textwidth]{convolution_example.png}
\caption{%
    An example showing different modes of convolution available in the \python
    ecosystem.  The red x's mark pixels that are set to NaN in the original data
    (a).  If the data are convolved with a Gaussian kernel on a 9x9 grid using
    scipy's direct convolution (b), any pixel within range of the original NaN
    pixels is also set to NaN.  Panel (c) shows what happens if the NaNs are set
    to zero first: the originally NaN regions are depressed relative to their
    surroundings.  Finally, panel (d) shows \astropypkg's convolution behavior,
    where the missing pixels are replaced with values interpolated from their
    surroundings using the convolution kernel.
    \label{fig:convolution-example}
}
\end{figure}


\subsection{Visualization}
% Larry:  Image visualization (stretching, scaling), RGB

The \package{visualization} package provides functionality that can be helpful when visualizing data. This includes a framework for plotting astronomical images with coordinates with Matplotlib (previously the standalone \package{wcsaxes} package), functionality related to image normaliation (including both scaling and stretching), smart histogram plotting, RGB color image creation from separate images, and custom plotting styles for Matplotlib.

\subsubsection{Image Stretching and Normalization}

The \package{visualization} package provides a framework for transforming values in images (and more generally any arrays), typically for the purpose of visualization. Two main types of transformations are normalization and stretching of image values.

Normalization transforms the images values to the [0:1] range using lower and upper limits where $x$ represents the values in the original image:

\begin{equation}
y = \frac{x - v_{vmin}}{v_{max} - v_{min}}
\end{equation}

Stretching transforms the image values in the [0:1] range to the [0:1] range using a linear or non-linear function:
\begin{equation}
z = f(y)
\end{equation}

In addition, classes are provided in order to identify lower and upper limits for a dataset based on specific algorithms (such as using percentiles).

Identifying lower and upper limits, as well as re-normalizing, is described in the Intervals and Normalization section, while stretching is described in the Stretching section.

\subsubsection{WCSAxes}
% Tom R.

\subsubsection{Choosing Histogram Bins}

\subsubsection{Creating color RGB images}
% include images

%\subsection{Utils}
% Lim

\subsection{Cosmology}


\subsection{Statistics}

The \astropypkg \package{stats} package provides
statistical tools that are useful for or specific to
astronomy and are not found in other \python\
statistics packages such as \package{scipy}
\citep{scipy} or \package{statsmodels}
\citep{seabold2010statsmodels}.   The
\package{stats} package contains a range of
different functionality used by many different
disciplines in astronomy.   It is not a complete set
of statistic tools, but rather a still growing
collection of useful features.

The current review process for contributions to the \package{stats} package includes review of the code, documentation, testing, and scientific merit of the inclusion.  When necessary, scientific reviewers outside of the maintainers will be sought for their input on new pull requests.

In this section, we describe these tools that provide a range of different functionality including robust statistical estimators, circular statistics, periodograms, spatial statistics, and histogram binning.


% Steve C.: overview, circular stats,
% Jake V.:  Lomb-scargle, Bayesian blocks
% Larry:  sigma clipping, biweight stats
% Ze':  Ripley's K (spatial stats)


\subsubsection{Robust Statistical Estimators}

Robust statistics provide reliable estimates of basic statistics for complex distributions. The \package{stats} package includes several robust statistical functions that are commonly used in astronomy. This includes methods for rejecting outliers as well as statistical description of the underlying distributions.

\subsubsection{Sigma Clipping}

Sigma clipping provides a fast method to identify outliers in a distribution. For a distribution of points, a center and a standard deviation are calculated. Values which are a set number of sigma times the standard deviation away from the center are rejected. The process can be iterated to further reject outliers.

\subsubsection{Median Absolute Deviation}

The median abosolute deviation (MAD) is a measure of the spread of a distribution and is defined as median(abs(a - median(a))). For a normal distribution, the MAD is related to the standard deviation by a factor of 1.4826, and a convenience function is available to apply the conversion.

\subsubsection{Biweight Estimators}

A set of functions are included in the \package{stats} package that use the biweight formalism. These functions have long been used in astronomy, particularly to calculate the velocity dispersion of galaxy clusters [XXX].

\subsubsection{Circular Statistics}
%steve
\subsubsection{Lomb-Scargle Periodograms}
%jake
\subsubsection{Ripley's K Function Estimators}
%ze
\subsubsection{Histogram Binning}
%jake

\section{Infrastructure for affiliated packages}
\label{sec:infrastructure}
\inlinecomment{BMS}{should we use links to the appropriate github repo?}
\inlinecomment{BMS}{should we describe astropy-helpers even though it's future is unsure?}
%
\par In addition to astronomy related packages and libraries, the \astropy\
Project also contains and supports several infrastructure package that are
very generic. The following sections describes the most widely used
selection of them.
%
\subsection{Package template}
% Brigitta may write this up if there is no other takers
\par \astropy provides a template package that any \python package is welcome to
use (many affiliated packages do so). The template contains a ready-to-go
package layout. It provides infrastructure such as documentation tools,
testing framework and CI templates and configurations, Cython integration,
and documentation on how to make it all work.
%
\subsection{Continuous integration helpers}
% Brigitta
\package{ci-helpers} is a collection of scripts that empowers package
maintainers to control their testing set up and installation process for
various continuous integration services via a set of environment
variables. While the current development is mostly driven by the needs of
the \astropy ecosystem, the actual usage of this package is extremely
widespread. Currently we support setups for TravisCI and AppveyorCI.
%
\subsection{sphinx extensions}
% Tom R


% \section{State of the Ecosystem}
% Commenting out unless a clear statement is added

\section{Learning Astropy}
\label{sec:learning}
% Kelle, Adrian
\inlinecomment{BMS}{would astropy learn mature enough to described in the paper, or maybe it should go as a subsection for the next, future of astropy section?}

Explain components: Documentation, Tutorials, and lessons

\section{The future of the Astropy project}
\label{sec:future}
\subsection{Roadmap for \python 3 only support}

dropping \python 2 support, growths of affiliated packages
Summary

\acknowledgments

Who to thank?  numfocus,

CI services? GitHub?

%% Similar to \facility{}, there is the optional \software command to allow
%% authors a place to specify which programs were used during the creation of
%% the manusscript. Authors should list each code and include either a
%% citation or url to the code inside ()s when available.

\software{\package{astropy} (\citealt{astropy}),
          \package{numpy} (\citealt{numpy}),
          \package{scipy} (\url{https://www.scipy.org/}),
          \package{matplotlib} (\url{https://matplotlib.org/}),
          }

\bibliographystyle{aasjournal}
\bibliography{bibliography}





\end{document}

